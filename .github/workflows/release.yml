name: Release (Velopack)

on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      force:
        description: "Build and publish even if tag already exists"
        required: false
        default: "false"

permissions:
  contents: write

concurrency:
  group: velopack-release-${{ github.ref }}
  cancel-in-progress: true

env:
  # Можно оставить как имя. Workflow сам найдёт реальный путь, если файла тут нет.
  CS_PROJ: LegendBorn.csproj

  PACK_ID: LegendBornLauncher
  MAIN_EXE: LegendBorn.exe
  PACK_TITLE: LegendBorn Launcher
  VPK_VERSION: 0.0.1369-g1d5c984
  VPK_OUTPUT_DIR: Releases
  VPK_CHANNEL: win
  FORCE_RELEASE: ${{ github.event_name == 'workflow_dispatch' && inputs.force == 'true' }}

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install .NET 10 + .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: |
            10.0.x
            8.0.x

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: |
            ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj', '**/*.props', '**/*.targets', '**/packages.lock.json') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      # 1) Находим правильный csproj (если CS_PROJ не указывает на существующий файл)
      - name: Resolve csproj path
        id: csproj
        shell: pwsh
        run: |
          $candidate = "${{ env.CS_PROJ }}".Trim()
          $resolved = $null

          if (![string]::IsNullOrWhiteSpace($candidate) -and (Test-Path $candidate)) {
            $resolved = (Resolve-Path $candidate).Path
          } else {
            # Ищем по репозиторию:
            # - сначала точное имя LegendBorn.csproj (частый кейс)
            # - иначе берём первый *.csproj
            $exact = Get-ChildItem -Recurse -Filter "LegendBorn.csproj" -File | Select-Object -First 1
            if ($exact) {
              $resolved = $exact.FullName
            } else {
              $first = Get-ChildItem -Recurse -Filter "*.csproj" -File | Select-Object -First 1
              if ($first) { $resolved = $first.FullName }
            }
          }

          if (-not $resolved) {
            Write-Host "Found csproj files:"
            Get-ChildItem -Recurse -Filter "*.csproj" -File | Select-Object FullName | Format-Table -AutoSize | Out-String | Write-Host
            throw "csproj not found. Set env.CS_PROJ to correct path."
          }

          "path=$resolved" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "Resolved csproj: $resolved"

      # 2) Читаем Version из найденного csproj
      - name: Read Version from csproj
        id: ver
        shell: pwsh
        run: |
          $proj = "${{ steps.csproj.outputs.path }}"
          if (!(Test-Path $proj)) { throw "csproj not found: $proj" }

          [xml]$xml = Get-Content -Raw -Path $proj

          # Берём Version из PropertyGroup (fallback: InformationalVersion/AssemblyVersion)
          $pg = $xml.Project.PropertyGroup

          $v = ($pg | Where-Object { $_.Version } | Select-Object -ExpandProperty Version -First 1)
          if (-not $v) {
            $v = ($pg | Where-Object { $_.InformationalVersion } | Select-Object -ExpandProperty InformationalVersion -First 1)
          }
          if (-not $v) {
            $v = ($pg | Where-Object { $_.AssemblyVersion } | Select-Object -ExpandProperty AssemblyVersion -First 1)
          }

          if ([string]::IsNullOrWhiteSpace($v)) {
            throw "Version not found in csproj (Version/InformationalVersion/AssemblyVersion)"
          }

          # На случай "0.2.2+sha" — отрезаем build metadata
          $v = $v.ToString().Split('+')[0].Trim()

          "version=$v" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "tag=v$v" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          Write-Host "Version=$v"
          Write-Host "Tag=v$v"

      - name: Check if tag already exists
        id: tagcheck
        shell: pwsh
        run: |
          git fetch --tags --force
          $tag = "${{ steps.ver.outputs.tag }}"
          $exists = (git tag -l $tag)

          $force = "${{ env.FORCE_RELEASE }}".ToLowerInvariant() -eq "true"
          if ($exists -and -not $force) {
            "exists=true" | Out-File $env:GITHUB_OUTPUT -Append
            Write-Host "Tag $tag exists. FORCE_RELEASE=false -> will skip."
          } else {
            "exists=false" | Out-File $env:GITHUB_OUTPUT -Append
            if ($exists -and $force) {
              Write-Host "Tag $tag exists, but FORCE_RELEASE=true -> will continue."
            } else {
              Write-Host "Tag $tag does not exist -> will continue."
            }
          }

      - name: Restore
        if: steps.tagcheck.outputs.exists != 'true'
        shell: pwsh
        run: |
          dotnet restore "${{ steps.csproj.outputs.path }}"

      - name: Publish app
        if: steps.tagcheck.outputs.exists != 'true'
        shell: pwsh
        run: |
          dotnet publish "${{ steps.csproj.outputs.path }}" -c Release -r win-x64 --self-contained true -o publish

      - name: Install/Update vpk tool
        if: steps.tagcheck.outputs.exists != 'true'
        shell: pwsh
        run: |
          dotnet tool update -g vpk --version "${{ env.VPK_VERSION }}"
          "$env:USERPROFILE\.dotnet\tools" | Out-File -FilePath $env:GITHUB_PATH -Append
          vpk --help

      - name: Download previous releases (optional)
        if: steps.tagcheck.outputs.exists != 'true'
        shell: pwsh
        continue-on-error: true
        run: |
          vpk download github `
            --repoUrl "https://github.com/${{ github.repository }}" `
            --token "${{ secrets.GITHUB_TOKEN }}" `
            --outputDir "${{ env.VPK_OUTPUT_DIR }}" `
            --channel "${{ env.VPK_CHANNEL }}"

      - name: Create Velopack packages
        if: steps.tagcheck.outputs.exists != 'true'
        shell: pwsh
        run: |
          vpk pack `
            --packId "${{ env.PACK_ID }}" `
            --packVersion "${{ steps.ver.outputs.version }}" `
            --packDir "publish" `
            --mainExe "${{ env.MAIN_EXE }}" `
            --packTitle "${{ env.PACK_TITLE }}" `
            --outputDir "${{ env.VPK_OUTPUT_DIR }}" `
            --channel "${{ env.VPK_CHANNEL }}" `
            --runtime "win-x64"

      - name: Upload GitHub Release
        if: steps.tagcheck.outputs.exists != 'true'
        shell: pwsh
        run: |
          vpk upload github `
            --repoUrl "https://github.com/${{ github.repository }}" `
            --token "${{ secrets.GITHUB_TOKEN }}" `
            --outputDir "${{ env.VPK_OUTPUT_DIR }}" `
            --channel "${{ env.VPK_CHANNEL }}" `
            --publish `
            --releaseName "${{ env.PACK_TITLE }} ${{ steps.ver.outputs.version }}" `
            --tag "${{ steps.ver.outputs.tag }}" `
            --targetCommitish "${{ github.sha }}"
